/*
 * Copyright (c) 2015 the original author or authors.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     Simon Scholz (vogella GmbH) - initial API and implementation and initial documentation
 */

package org.eclipse.buildship.ui.view.execution;

import org.eclipse.buildship.ui.UiPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.jdt.core.*;
import org.eclipse.jdt.core.search.*;
import org.eclipse.jdt.internal.corext.util.JavaConventionsUtil;
import org.eclipse.jdt.ui.JavaUI;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.widgets.Display;
import org.eclipse.ui.PartInitException;
import org.gradle.tooling.events.OperationDescriptor;
import org.gradle.tooling.events.test.JvmTestOperationDescriptor;
import org.osgi.framework.Bundle;
import org.osgi.framework.FrameworkUtil;

import java.util.ArrayList;
import java.util.List;

/**
 * A job, which is used to navigate to the source of a test, which is referenced by a given
 * {@link JvmTestOperationDescriptor}.
 *
 */
@SuppressWarnings("restriction")
public final class OpenTestCompilationUnitJob extends Job {

    private ISelection selection;
    private Display display;

    public OpenTestCompilationUnitJob(ISelection selection, Display display) {
        super("Open Compilation Unit");
        this.selection = selection;
        this.display = display;
    }

    @Override
    protected IStatus run(IProgressMonitor monitor) {
        if (this.selection instanceof IStructuredSelection) {
            List<?> list = ((IStructuredSelection) this.selection).toList();
            for (Object selectedItem : list) {
                if (selectedItem instanceof OperationItem) {
                    OperationDescriptor operationDescriptor = (OperationDescriptor) ((OperationItem) selectedItem).getAdapter(OperationDescriptor.class);
                    if (operationDescriptor instanceof JvmTestOperationDescriptor) {
                        IStatus status = searchForTestSource(monitor, (JvmTestOperationDescriptor) operationDescriptor);
                        if (!status.isOK()) {
                            return status;
                        }
                    }
                }
            }
        }

        return Status.OK_STATUS;
    }

    private IStatus searchForTestSource(IProgressMonitor monitor, final JvmTestOperationDescriptor testOperationDescriptor) {
        if (testOperationDescriptor.getClassName() != null) {
            try {

                SearchEngine searchEngine = new SearchEngine();

                IJavaSearchScope workspaceScope = SearchEngine.createWorkspaceScope();

                SearchPattern pattern = SearchPattern.createPattern(testOperationDescriptor.getClassName(), IJavaSearchConstants.TYPE, IJavaSearchConstants.DECLARATIONS,
                        SearchPattern.R_EXACT_MATCH);

                SearchRequestor requestor = new SearchRequestor() {

                    @Override
                    public void acceptSearchMatch(SearchMatch match) throws CoreException {
                        if (match.getElement() instanceof IType) {
                            IType type = (IType) match.getElement();
                            final IJavaElement javaElement = findMethod(type, testOperationDescriptor.getMethodName());
                            if (javaElement != null) {
                                OpenTestCompilationUnitJob.this.display.asyncExec(new Runnable() {

                                    @Override
                                    public void run() {
                                        try {
                                            JavaUI.openInEditor(javaElement);
                                        } catch (PartInitException e) {
                                            UiPlugin.logger().error(e.getMessage(), e);
                                        } catch (JavaModelException e) {
                                            UiPlugin.logger().error(e.getMessage(), e);
                                        }
                                    }
                                });
                            }
                        }
                    }
                };

                searchEngine.search(pattern, new SearchParticipant[] { SearchEngine.getDefaultSearchParticipant() }, workspaceScope, requestor, monitor);

            } catch (CoreException e) {
                UiPlugin.logger().error(e.getMessage(), e);
                Bundle bundle = FrameworkUtil.getBundle(getClass());
                return new Status(Status.ERROR, bundle.getSymbolicName(), e.getMessage(), e);
            }

        }
        return Status.OK_STATUS;
    }

    /**
     * Copy of org.eclipse.jdt.internal.junit.ui.OpenTestAction.findMethod(IType).
     */
    private IJavaElement findMethod(IType type, String methodName) {
        IStatus status = JavaConventionsUtil.validateMethodName(methodName, type);
        if (!status.isOK()) {
            return type;
        }
        IMethod method = type.getMethod(methodName, new String[0]);
        if (method != null && method.exists()) {
            return method;
        }

        // search just by name, if method not found yet (for custom runner with test methods having
        // parameters)
        try {
            List<IMethod> foundMethods = new ArrayList<IMethod>();
            for (IMethod methodItem : type.getMethods()) {
                String methodItemName = methodItem.getElementName();
                IAnnotation methodAnnotation = methodItem.getAnnotation("Test"); //$NON-NLS-1$

                // JUnit3 test method starts with "test" or JUnit4 test method is annotated with
                // "@Test"
                if (!(methodItemName.startsWith("test") || (methodAnnotation != null && methodAnnotation.exists()))) {
                    continue;
                }

                if (methodItemName.equals(methodItemName)) {
                    foundMethods.add(methodItem);
                }
            }
            if (foundMethods.isEmpty()) {
                return type;
            } else {
                return foundMethods.get(0);
            }
        } catch (JavaModelException e) {
            // if type does not exist or if an exception occurs while accessing its resource =>
            // ignore (no method found)
        }

        return type;
    }

}
